import Ajv, { type Options } from 'ajv';
import addFormats, { type FormatOptions } from 'ajv-formats';
import standaloneCode from 'ajv/dist/standalone';
import * as Esbuild from 'esbuild-wasm';
import { Parser, type JSONSchema } from 'json-schema-to-dts';

export interface SchemaEntry {
  uri: string;
  schema: Exclude<JSONSchema, boolean>;
  preferredName?: string;
}

type AnyType = 'any' | 'JSONValue' | 'unknown';
export interface GenerateCodecCodeOptions {
  anyType?: AnyType;
  ajvOptions?: Omit<Options, 'allErrors' | 'code' | 'inlineRefs'>;
  ajvFormatsOptions?: FormatOptions;
  /**
   * The code generated by this library depends on `@ggoodman/typed-validator`.
   * When `externalizeValidatorLibrary` is true, then the generated code will
   * assume that the `@ggoodman/typed-validator` library is available in the
   * runtime environment.
   *
   * By default, that library is embedded into the generated code.
   */
  externalizeValidatorLibrary?: boolean;
  validateFormats?: boolean;
  moduleFormat?: Esbuild.Format;

  /**
   * Schema field that, when truthy, will result in the sub-schema being omitted
   * in the generated types.
   */
  omitEmitField?: `x-${string}`;
}

export interface GenerateResult {
  /**
   * JavaScript code in the selected module format that implements typed validator
   * objects for each top-level input schema. The exported symbol for each input
   * schema can be determined by referencing the `schamaPathsToCodecNames` map.
   *
   * The validation codecs can be found as properties of the `Codecs` export.
   */
  javaScript: string;

  /**
   * TypeScript type definitions for the external API exposed by the returned
   * JavaScript code. Additionally, a type-only namespace of typescript types
   * corresponding to the input schemas is exported in the `Types` namespace.
   */
  typeDefinitions: string;
  /**
   * A map of input schema paths to the exported symbol name for that schema.
   *
   * Sometimes, collisions in names might force a different symbol to be used.
   */
  schamaPathsToCodecNames: Record<string, string>;
}

export async function generateCodecCode(
  schemas: SchemaEntry[],
  options: GenerateCodecCodeOptions = {},
): Promise<GenerateResult> {
  const parser = new Parser({
    defaultUnknownPropertiesSchema: true,
  });
  const ajv = new Ajv({
    verbose: true,
    validateFormats: options.validateFormats,
    ...(options.ajvOptions ?? {}),
    allErrors: true,
    code: {
      es5: false, // use es6
      lines: true,
      optimize: true, // we'll let rollup do this
      source: true,
      esm: true,
    },
    inlineRefs: false,
  });

  if (options.validateFormats) {
    addFormats(ajv, options.ajvFormatsOptions);
  }

  if (options.omitEmitField) {
    ajv.addKeyword({
      keyword: options.omitEmitField,
      schemaType: 'boolean',
      errors: false,
    });
  }

  // We want to produce a pair of files; the first is the JavaScript code for
  // the validator functions for each schema, and the second is the TypeScript
  // type definitions for the exported API.
  //
  // Given a schema named 'Schema', we want the following exports:
  // ```ts
  // export type Schema = { /* ... */ };
  // export function createSchema(obj: Schema): Schema;
  // export function isSchema(value: unknown): value is Schema;
  // export function validateSchema(value: unknown): Schema;
  // ```

  const moduleFormat = options.moduleFormat || 'cjs';
  const exportedNameToSchema: Record<string, JSONSchema> = {};
  const uriToExportedName: Record<string, string> = {};
  const exportedNameToURI: Record<string, string> = {};
  /**
   * A collection of exported names used to add safety to some risky
   * regex-based code rewriting of `exports.<symbol> = ` to `export const <symbol> = `.
   */
  const exportedNames = new Set<string>();

  const schemaEntries: Map<
    string,
    { uri: string; preferredName: string; jsLines: string[]; tsdLines: string[] }
  > = new Map();

  for (const { schema, uri, preferredName } of schemas) {
    const name = parser.addSchema(uri, schema, { preferredName });
    const schemaWithId: JSONSchema = { $id: uri, ...schema };

    if (exportedNames.has(name)) {
      throw new Error(
        `Invariant violation: The name ${JSON.stringify(name)} was expored more than once`,
      );
    }

    exportedNames.add(name);
    uriToExportedName[uri] = name;
    exportedNameToURI[name] = schemaWithId.$id!;
    exportedNameToSchema[name] = schemaWithId;

    ajv.addSchema(schemaWithId, name);

    const jsLines: string[] = [
      `export { ${name} as validate${name} } from '/virtual/validators.js';`,
    ];
    const tsdLines: string[] = [`export const validate${name}: ValidatorFunction<${name}>;`];

    schemaEntries.set(name, { uri, preferredName: name, jsLines, tsdLines });
  }

  const { diagnostics, text: schemaTypeDefs } = parser.compile({
    topLevel: {
      hasDeclareKeyword: false,
      isExported: true,
    },
    anyType: options.anyType ?? 'JSONValue',
    // Skip emitting reference comments
    omitIdComments: true,

    shouldOmitTypeEmit(node) {
      const omitField = options?.omitEmitField;

      if (!omitField) {
        // Always emit if we don't have a special field configured;
        return false;
      }

      if (typeof node.schema !== 'object' && node.schema != null) {
        // Always emit for boolean (and other?) schemas since we can't
        // have user-defined properties of non-object and null schemas.
        return false;
      }

      return !!node.schema[omitField];
    },
  });

  if (diagnostics.length) {
    throw new Error(
      `Produced diagnostics while generating type definitions for schemas: ${diagnostics
        .map((diagnostic) => `${diagnostic.message}`)
        .join('\n')}`,
    );
  }

  const standaloneValidationCode = standaloneCode(ajv, exportedNameToURI);

  const virtualFiles: Map<string, string> = new Map();

  virtualFiles.set('/virtual/validators.js', standaloneValidationCode);
  virtualFiles.set(
    '/virtual/index.js',
    [...schemaEntries].flatMap(([, { jsLines }]) => jsLines).join('\n'),
  );

  const bundleResult = await Esbuild.build({
    bundle: true,
    define: {
      'process.env.NODE_ENV': JSON.stringify('production'),
    },
    format: moduleFormat,
    entryPoints: ['/virtual/index.js'],
    outfile: 'codecs.js',
    platform: 'neutral',
    plugins: [
      {
        name: 'virtual-files',
        setup(build) {
          build.onResolve({ filter: /^\/virtual\/.*/ }, async (args) => {
            if (virtualFiles.has(args.path)) {
              return {
                path: args.path,
                namespace: 'virtual-file',
              };
            }
          });
          build.onLoad({ filter: /.*/, namespace: 'virtual-file' }, async (args) => {
            const contents = virtualFiles.get(args.path);

            if (contents == null) {
              throw new Error(`Invariant violation: No contents for ${args.path}`);
            }

            return {
              contents,
              loader: 'js',
              resolveDir: __dirname,
            };
          });
        },
      },
    ],
    target: 'node16',
    treeShaking: true,
    write: false,
  });

  if (bundleResult.outputFiles.length !== 1) {
    throw new Error(
      `Invariant violation: Produced ${bundleResult.outputFiles.length}, expecting exactly 1`,
    );
  }

  const javaScript = bundleResult.outputFiles[0].text;

  const typeDefinitions = `
    export interface ErrorObject {
      instancePath: string;
      message?: string;
      data?: unknown;
    }

    export interface ValidatorFunction<T> {
      (obj: unknown): obj is T;
      errors?: ErrorObject[];
    }

    ${schemaTypeDefs}

    ${[...schemaEntries].flatMap(([, { tsdLines }]) => tsdLines).join('\n')}
  `;

  return {
    javaScript,
    typeDefinitions,
    schamaPathsToCodecNames: uriToExportedName,
  };
}
