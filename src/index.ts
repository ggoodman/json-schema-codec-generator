import Ajv, { type Options } from 'ajv';
import addFormats, { type FormatOptions } from 'ajv-formats';
import standaloneCode from 'ajv/dist/standalone';
import * as Esbuild from 'esbuild-wasm';
import { readFile } from 'fs/promises';
import { type JSONSchema, Parser } from 'json-schema-to-dts';
import { dirname, join, resolve } from 'path';

export interface SchemaEntry {
  uri: string;
  schema: Exclude<JSONSchema, boolean>;
  preferredName?: string;
}

type AnyType = 'any' | 'JSONValue' | 'unknown';
export interface GenerateCodecCodeOptions {
  anyType?: AnyType;
  ajvOptions?: Omit<Options, 'allErrors' | 'code' | 'inlineRefs'>;
  ajvFormatsOptions?: FormatOptions;
  /**
   * The code generated by this library depends on `@ggoodman/typed-validator`.
   * When `externalizeValidatorLibrary` is true, then the generated code will
   * assume that the `@ggoodman/typed-validator` library is available in the
   * runtime environment.
   *
   * By default, that library is embedded into the generated code.
   */
  externalizeValidatorLibrary?: boolean;
  validateFormats?: boolean;
  moduleFormat?: Esbuild.Format;
}

export interface GenerateResult {
  /**
   * JavaScript code in the selected module format that implements typed validator
   * objects for each top-level input schema. The exported symbol for each input
   * schema can be determined by referencing the `schamaPathsToCodecNames` map.
   *
   * The validation codecs can be found as properties of the `Codecs` export.
   */
  javaScript: string;

  /**
   * TypeScript type definitions for the external API exposed by the returned
   * JavaScript code. Additionally, a type-only namespace of typescript types
   * corresponding to the input schemas is exported in the `Types` namespace.
   */
  typeDefinitions: string;
  /**
   * A map of input schema paths to the exported symbol name for that schema.
   *
   * Sometimes, collisions in names might force a different symbol to be used.
   */
  schamaPathsToCodecNames: Record<string, string>;
}

export async function generateCodecCode(
  schemas: SchemaEntry[],
  options: GenerateCodecCodeOptions = {}
): Promise<GenerateResult> {
  const parser = new Parser();
  const ajv = new Ajv({
    verbose: true,
    validateFormats: options.validateFormats,
    ...(options.ajvOptions ?? {}),
    allErrors: true,
    code: {
      es5: false, // use es6
      lines: true,
      optimize: false, // we'll let rollup do this
      source: true,
    },
    inlineRefs: false,
  });

  if (options.validateFormats) {
    addFormats(ajv, options.ajvFormatsOptions);
  }

  const moduleFormat = options.moduleFormat || 'cjs';
  const exportedNameToSchema: Record<string, JSONSchema> = {};
  const uriToExportedName: Record<string, string> = {};
  /**
   * A collection of exported names used to add safety to some risky
   * regex-based code rewriting of `exports.<symbol> = ` to `export const <symbol> = `.
   */
  const exportedNames = new Set<string>();
  const codecDefinitions: string[] = [];
  const codecInstances: string[] = [];

  for (const { schema, uri, preferredName } of schemas) {
    const schemaWithId: JSONSchema = { $id: uri, ...schema };
    const name = parser.addSchema(uri, schemaWithId, { preferredName });

    if (exportedNames.has(name)) {
      throw new Error(
        `Invariant violation: The name ${JSON.stringify(name)} was expored more than once`
      );
    }

    exportedNames.add(name);
    uriToExportedName[uri] = name;
    exportedNameToSchema[name] = schemaWithId;

    ajv.addSchema(schemaWithId, validatorNameForCodec(name));

    codecDefinitions.push(`${name}: Codec<Types.${name}>`);
    codecInstances.push(
      `${name}: createCodec<Types.${name}>(${JSON.stringify(name)}, ${JSON.stringify(
        uri
      )}, exports.${validatorNameForCodec(name)}) as Codec<Types.${name}>`
    );
  }

  const { diagnostics, text: schemaTypeDefs } = parser.compile({
    topLevel: {
      hasDeclareKeyword: false,
      isExported: true,
    },
    anyType: options.anyType ?? 'JSONValue',
  });

  if (diagnostics.length) {
    throw new Error(
      `Produced diagnostics while generating type definitions for schemas: ${diagnostics
        .map((diagnostic) => `${diagnostic.message}`)
        .join('\n')}`
    );
  }

  const standaloneValidationCode = standaloneCode(ajv);
  const bundleResult = await Esbuild.build({
    bundle: true,
    define: {
      'process.env.NODE_ENV': JSON.stringify('production'),
    },
    external: options.externalizeValidatorLibrary === true ? ['@ggoodman/typed-validator'] : [],
    format: moduleFormat,
    outfile: 'codecs.js',
    platform: 'neutral',
    stdin: {
      contents: `
import { createCodec } from '@ggoodman/typed-validator';

export * from '@ggoodman/typed-validator';

${standaloneValidationCode}

export const Codecs = {
  ${codecInstances.join(',\n')}
} as const;

      `,
      loader: 'ts',
      sourcefile: 'src/index.ts',
      resolveDir: __dirname,
    },
    target: 'node10',
    treeShaking: true,
    write: false,
  });

  if (bundleResult.outputFiles.length !== 1) {
    throw new Error(
      `Invariant violation: Produced ${bundleResult.outputFiles.length}, expecting exactly 1`
    );
  }

  const javaScript = bundleResult.outputFiles[0].text;
  const typeDefinitions = `
${await readTypes('@ggoodman/typed-validator')};

export namespace Types {
  ${schemaTypeDefs.split('\n').join('\n  ')}
}

export declare const Codecs: {
  ${codecDefinitions.join(',\n  ')}
};
  `;

  return {
    javaScript,
    typeDefinitions,
    schamaPathsToCodecNames: uriToExportedName,
  };
}

function validatorNameForCodec(codecName: string) {
  return `__validate_${codecName}`;
}

function readTypes(moduleName: string) {
  const packageJsonPath = require.resolve(join(moduleName, 'package.json'));
  const packageJson = require(packageJsonPath);
  const typesPath = resolve(dirname(packageJsonPath), packageJson['types']);

  return readFile(typesPath, { encoding: 'utf-8' });
}
