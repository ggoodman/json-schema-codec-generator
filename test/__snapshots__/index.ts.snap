// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Codec generation will produce the expected code 1`] = `
"\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", { value: true });

class ValidationError extends Error {
  constructor(schemaName, value, validatorErrors) {
    const errorStrings = validatorErrors.map((err) => {
      return \`  \${err.message} at \${
        err.dataPath || \\"#\\"
      }, got \${valueToShapeString(err.data)}\`;
    });
    super(
      \`Validation for the schema \${JSON.stringify(
        schemaName
      )} failed with the following errors:\\\\n\${errorStrings.join(\\"\\\\n\\")}\`
    );
    this.value = value;
    this.validatorErrors = validatorErrors;
  }

  static isValidationError(err) {
    return err instanceof this;
  }
}

function valueToShapeString(value) {
  return JSON.stringify(value, valueToShapeReplacer);
}

function valueToShapeReplacer(_key, value) {
  return typeof value === \\"object\\" && value ? value : typeof value;
}

class CodecImpl {
  constructor(name, uri, validateFn) {
    this.name = name;
    this.uri = uri;
    this.validateFn = validateFn;
  }
  /**
   * Identify function returning the given argument as a value matching the schema.
   *
   * This can be useful to use in non-TypeScript code to construct a valid object while
   * benefitting from suggestions from a TypeScript language service.
   */

  identity(obj) {
    return obj;
  }
  /**
   * Check if a value matches the schema.
   */

  is(obj) {
    return this.validateFn(obj);
  }
  /**
   * Validate that a value matches the schema and throws if not.
   */

  validate(obj) {
    if (!this.validateFn(obj)) {
      throw new ValidationError(this.name, obj, this.validateFn.errors || []);
    }

    return obj;
  }
}

var types = /*#__PURE__*/ Object.freeze({
  __proto__: null,
});

const User = validate21;
const schema6 = {
  $id: \\"file:///User.json\\",
  title: \\"A User Object\\",
  description: \\"A user is a known visitor.\\",
  type: \\"object\\",
  properties: {
    id: {
      type: \\"string\\",
    },
    name: {
      type: \\"string\\",
    },
  },
  required: [\\"id\\", \\"name\\"],
};

function validate21(
  data,
  { dataPath = \\"\\", parentData, parentDataProperty, rootData = data } = {}
) {
  let vErrors = null;
  let errors = 0;

  if (data && typeof data == \\"object\\" && !Array.isArray(data)) {
    if (data.id === undefined) {
      const err0 = {
        keyword: \\"required\\",
        dataPath,
        schemaPath: \\"#/required\\",
        params: {
          missingProperty: \\"id\\",
        },
        message: \\"should have required property '\\" + \\"id\\" + \\"'\\",
        schema: schema6.required,
        parentSchema: schema6,
        data,
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    if (data.name === undefined) {
      const err1 = {
        keyword: \\"required\\",
        dataPath,
        schemaPath: \\"#/required\\",
        params: {
          missingProperty: \\"name\\",
        },
        message: \\"should have required property '\\" + \\"name\\" + \\"'\\",
        schema: schema6.required,
        parentSchema: schema6,
        data,
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    if (data.id !== undefined) {
      let data0 = data.id;

      if (typeof data0 !== \\"string\\") {
        const err2 = {
          keyword: \\"type\\",
          dataPath: dataPath + \\"/id\\",
          schemaPath: \\"#/properties/id/type\\",
          params: {
            type: \\"string\\",
          },
          message: \\"should be string\\",
          schema: schema6.properties.id.type,
          parentSchema: schema6.properties.id,
          data: data0,
        };

        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }

        errors++;
      }
    }

    if (data.name !== undefined) {
      let data1 = data.name;

      if (typeof data1 !== \\"string\\") {
        const err3 = {
          keyword: \\"type\\",
          dataPath: dataPath + \\"/name\\",
          schemaPath: \\"#/properties/name/type\\",
          params: {
            type: \\"string\\",
          },
          message: \\"should be string\\",
          schema: schema6.properties.name.type,
          parentSchema: schema6.properties.name,
          data: data1,
        };

        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }

        errors++;
      }
    }
  } else {
    const err4 = {
      keyword: \\"type\\",
      dataPath,
      schemaPath: \\"#/type\\",
      params: {
        type: \\"object\\",
      },
      message: \\"should be object\\",
      schema: schema6.type,
      parentSchema: schema6,
      data,
    };

    if (vErrors === null) {
      vErrors = [err4];
    } else {
      vErrors.push(err4);
    }

    errors++;
  }

  validate21.errors = vErrors;
  return errors === 0;
}

const BlogPost = validate22;
const schema7 = {
  $id: \\"file:///BlogPost.json\\",
  title: \\"A Blog Post\\",
  description: \\"A blog post represents an article associated with an author\\",
  type: \\"object\\",
  properties: {
    id: {
      type: \\"string\\",
    },
    title: {
      type: \\"string\\",
    },
    content: {
      type: \\"string\\",
    },
    author: {
      $ref: \\"file:///User.json\\",
    },
  },
  required: [\\"id\\", \\"title\\", \\"content\\", \\"user\\"],
};

function validate22(
  data,
  { dataPath = \\"\\", parentData, parentDataProperty, rootData = data } = {}
) {
  let vErrors = null;
  let errors = 0;

  if (data && typeof data == \\"object\\" && !Array.isArray(data)) {
    if (data.id === undefined) {
      const err0 = {
        keyword: \\"required\\",
        dataPath,
        schemaPath: \\"#/required\\",
        params: {
          missingProperty: \\"id\\",
        },
        message: \\"should have required property '\\" + \\"id\\" + \\"'\\",
        schema: schema7.required,
        parentSchema: schema7,
        data,
      };

      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }

      errors++;
    }

    if (data.title === undefined) {
      const err1 = {
        keyword: \\"required\\",
        dataPath,
        schemaPath: \\"#/required\\",
        params: {
          missingProperty: \\"title\\",
        },
        message: \\"should have required property '\\" + \\"title\\" + \\"'\\",
        schema: schema7.required,
        parentSchema: schema7,
        data,
      };

      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }

      errors++;
    }

    if (data.content === undefined) {
      const err2 = {
        keyword: \\"required\\",
        dataPath,
        schemaPath: \\"#/required\\",
        params: {
          missingProperty: \\"content\\",
        },
        message: \\"should have required property '\\" + \\"content\\" + \\"'\\",
        schema: schema7.required,
        parentSchema: schema7,
        data,
      };

      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }

      errors++;
    }

    if (data.user === undefined) {
      const err3 = {
        keyword: \\"required\\",
        dataPath,
        schemaPath: \\"#/required\\",
        params: {
          missingProperty: \\"user\\",
        },
        message: \\"should have required property '\\" + \\"user\\" + \\"'\\",
        schema: schema7.required,
        parentSchema: schema7,
        data,
      };

      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }

      errors++;
    }

    if (data.id !== undefined) {
      let data0 = data.id;

      if (typeof data0 !== \\"string\\") {
        const err4 = {
          keyword: \\"type\\",
          dataPath: dataPath + \\"/id\\",
          schemaPath: \\"#/properties/id/type\\",
          params: {
            type: \\"string\\",
          },
          message: \\"should be string\\",
          schema: schema7.properties.id.type,
          parentSchema: schema7.properties.id,
          data: data0,
        };

        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }

        errors++;
      }
    }

    if (data.title !== undefined) {
      let data1 = data.title;

      if (typeof data1 !== \\"string\\") {
        const err5 = {
          keyword: \\"type\\",
          dataPath: dataPath + \\"/title\\",
          schemaPath: \\"#/properties/title/type\\",
          params: {
            type: \\"string\\",
          },
          message: \\"should be string\\",
          schema: schema7.properties.title.type,
          parentSchema: schema7.properties.title,
          data: data1,
        };

        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }

        errors++;
      }
    }

    if (data.content !== undefined) {
      let data2 = data.content;

      if (typeof data2 !== \\"string\\") {
        const err6 = {
          keyword: \\"type\\",
          dataPath: dataPath + \\"/content\\",
          schemaPath: \\"#/properties/content/type\\",
          params: {
            type: \\"string\\",
          },
          message: \\"should be string\\",
          schema: schema7.properties.content.type,
          parentSchema: schema7.properties.content,
          data: data2,
        };

        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }

        errors++;
      }
    }

    if (data.author !== undefined) {
      let data3 = data.author;

      if (
        !validate21(data3, {
          dataPath: dataPath + \\"/author\\",
          parentData: data,
          parentDataProperty: \\"author\\",
          rootData,
        })
      ) {
        vErrors =
          vErrors === null
            ? validate21.errors
            : vErrors.concat(validate21.errors);
        errors = vErrors.length;
      }
    }
  } else {
    const err7 = {
      keyword: \\"type\\",
      dataPath,
      schemaPath: \\"#/type\\",
      params: {
        type: \\"object\\",
      },
      message: \\"should be object\\",
      schema: schema7.type,
      parentSchema: schema7,
      data,
    };

    if (vErrors === null) {
      vErrors = [err7];
    } else {
      vErrors.push(err7);
    }

    errors++;
  }

  validate22.errors = vErrors;
  return errors === 0;
}

const Codecs = {
  User: new CodecImpl(\\"User\\", \\"file:///User.json\\", User),
  BlogPost: new CodecImpl(\\"BlogPost\\", \\"file:///BlogPost.json\\", BlogPost),
};

exports.Codecs = Codecs;
exports.Types = types;
"
`;

exports[`Codec generation will produce the expected code 2`] = `
Object {
  "file:///BlogPost.json": "BlogPost",
  "file:///User.json": "User",
}
`;

exports[`Codec generation will produce the expected code 3`] = `
"interface Codec<T> {
    /**
     * Identify function returning the given argument as a value matching the schema.
     *
     * This can be useful to use in non-TypeScript code to construct a valid object while
     * benefitting from suggestions from a TypeScript language service.
     */
    identity(obj: T): T;
    /**
     * Check if a value matches the schema.
     */
    is(obj: unknown): obj is T;
    /**
     * Validate that a value matches the schema and throws if not.
     */
    validate(obj: unknown): T;
}
declare namespace Types {
    /**
     * A User Object
     *
     * A user is a known visitor.
     * @see file:///User.json
     */
    type User = {
        id: string;
        name: string;
    };
    /**
     * A Blog Post
     *
     * A blog post represents an article associated with an author
     * @see file:///BlogPost.json
     */
    type BlogPost = {
        id: string;
        title: string;
        content: string;
        author?: User;
    };
}
declare const Codecs: {
    readonly User: Codec<Types.User>;
    readonly BlogPost: Codec<Types.BlogPost>;
};
export { Codec, Types, Codecs };
"
`;
